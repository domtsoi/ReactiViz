/* Lab 6 base code - transforms using local matrix functions
	to be written by students -
	based on lab 5 by CPE 471 Cal Poly Z. Wood + S. Sueda
	& Ian Dunn, Christian Eckhardt
*/
#include <iostream>
#include <algorithm>
#include <glad/glad.h>
#include <time.h>
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include "GLSL.h"
#include "Program.h"
#include "Shape.h"
#include "MatrixStack.h"
#include "WindowManager.h"
#include "camera.h"
// used for helper in perspective
#include "glm/glm.hpp"
// value_ptr for glm
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <thread>

#include "recordAudio.h"
#include "kiss_fft.h"




extern captureAudio actualAudioData;
extern int running;


#define NOAUDIO

#define CITYSLOTS 40
#define BULDINGDIST 0.8
#define CITYSIZE (CITYSLOTS * BULDINGDIST * 2.0)
#define CITYMULSCALE 3
#define CUBE_TEXTURE_SIZE 512
#define CHANGEMODETIME 4

const float antialiasing = 1.5;

bool fullscreen = false;
const bool forceresolution = false;
#define FORCERESX 1280
#define FORCERESY 720


#define FFTW_ESTIMATEE (1U << 6)
#define FFT_MAXSIZE 500

class StopWatchMicro_
	{
	private:
		LARGE_INTEGER last, frequency;
	public:
		StopWatchMicro_()
			{
			QueryPerformanceFrequency(&frequency);
			QueryPerformanceCounter(&last);

			}
		long double elapse_micro()
			{
			LARGE_INTEGER now, dif;
			QueryPerformanceCounter(&now);
			dif.QuadPart = now.QuadPart - last.QuadPart;
			long double fdiff = (long double)dif.QuadPart;
			fdiff /= (long double)frequency.QuadPart;
			return fdiff * 1000000.;
			}
		long double elapse_milli()
			{
			elapse_micro() / 1000.;
			}
		void start()
			{
			QueryPerformanceCounter(&last);
			}
	};

enum rendermodes { MODE_CITYFWD, MODE_CITYSTATIC,MODE_LANDFWD,MODE_LANDSTATIC };
rendermodes rendermode = MODE_CITYFWD;
camera mycam;

#define MAXLASERS 10000
#define LASERTRIGGERMUL 1.0
#define LASERAGINGMUL 3.0
class laser_
	{
	public:
		vec3 pos;
		float weight = 8;
		float age = 1.5;
		vec2 rg_col = vec2(0);

		int reservour_index = -1;
		ivec2 fieldpos = ivec2(0, 0);
		void aging(float frametime)
			{
			if (age > 0) age -= frametime * LASERAGINGMUL;
			else age = 1.5;
			}
	};
vector<laser_> laser_reservour;
vector<UINT> laser_reservour_index_stack;
vector<laser_> active_lasers;
void change(UINT& a, UINT& b)
	{
	int c = a;
	a = b;
	b = c;
	}
void shuffle_lasers(int count)
	{
	int shuffle_count = count;
	if (count < 0) shuffle_count = laser_reservour_index_stack.size();
	else if (shuffle_count <= 0) return;
	for (int ii = 0; ii < shuffle_count; ii++)
		{
		int ia = rand() % shuffle_count;
		int ib = rand() % shuffle_count;
		change(laser_reservour_index_stack[ia], laser_reservour_index_stack[ib]);
		}
	}


class laser_vertex_
	{
	public:
		vec3 position, color, ageinfo;
		laser_vertex_()
			{
			position = ageinfo = vec3(0);
			color = vec3(1);
			}
	};

float lengthsq(vec3 v)
	{
	return v.x* v.x + v.y * v.y + v.z * v.z;
	}

bool compareInterval(laser_ a, laser_ b)
	{
	return (vec4(mycam.V * vec4(a.pos, 1)).z < vec4(mycam.V * vec4(b.pos, 1)).z);
	//return (lengthsq(a.pos+ mycam.pos) < lengthsq(b.pos+ mycam.pos));
	}

bool fft(float* amplitude_on_frequency, int& length)
	{


	int N = pow(2, 10);
	BYTE data[MAXS];
	int size = 0;
	actualAudioData.readAudio(data, size);
	length = size / 8;
	if (size == 0)
		return false;

	double* samples = new double[length];
	for (int ii = 0; ii < length; ii++)
		{
		float* f = (float*)& data[ii * 8];
		samples[ii] = (double)(*f);
		}


	kiss_fft_cpx* cx_in = new kiss_fft_cpx[length];
	kiss_fft_cpx* cx_out = new kiss_fft_cpx[length];
	kiss_fft_cfg cfg = kiss_fft_alloc(length, 0, 0, 0);
	for (int i = 0; i < length; ++i)
		{
		cx_in[i].r = samples[i];
		cx_in[i].i = 0;
		}

	kiss_fft(cfg, cx_in, cx_out);

	float amplitude_on_frequency_old[FFT_MAXSIZE];
	for (int i = 0; i < length / 2 && i < FFT_MAXSIZE; ++i)
		amplitude_on_frequency_old[i] = amplitude_on_frequency[i];

	for (int i = 0; i < length / 2 && i < FFT_MAXSIZE; ++i)
		amplitude_on_frequency[i] = sqrt(pow(cx_out[i].i, 2.) + pow(cx_out[i].r, 2.));


	//that looks better, decomment for no filtering: +++++++++++++++++++
	for (int i = 0; i < length / 2 && i < FFT_MAXSIZE; ++i)
		{
		float diff = amplitude_on_frequency_old[i] - amplitude_on_frequency[i];
		float attack_factor = 0.1;//for going down
		if (amplitude_on_frequency_old[i] < amplitude_on_frequency[i])
			attack_factor = 0.85; //for going up
		diff *= attack_factor;
		amplitude_on_frequency[i] = amplitude_on_frequency_old[i] - diff;
		}
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


	length /= 2;
	free(cfg);

	return true;
	}
#define min(a,b) ((a) < (b) ? (a) : (b))
#define max(a,b) ((a) > (b) ? (a) : (b))

float delayfilter(float old, float actual, float mul)
	{
	if (actual > old) return actual;
	float fold = (float)old;
	float factual = (float)actual;
	float fres = fold - (fold - factual) / mul;
	return (float)fres;
	}
float delay(float old, float actual, float mul)
	{
	float fold = (float)old;
	float factual = (float)actual;
	float fres = fold - (fold - factual) * mul;
	return (float)fres;
	}
double get_last_elapsed_time()
	{
	static double lasttime = glfwGetTime();
	double actualtime = glfwGetTime();
	double difference = actualtime - lasttime;
	lasttime = actualtime;
	return difference;
	}




using namespace std;
using namespace glm;
float frand()
	{
	return (float)rand() / 32768.0;
	}

class cityfieldelement_
	{
	public: float height = 0; bool laseractive = false;
	};

class Application : public EventCallbacks
	{

	public:
		bool beattrigger = false;
		int initialized_VB_laser_count = 0;
		float amplitude_on_frequency[FFT_MAXSIZE];
		float amplitude_on_frequency_10steps[10];

		float z_schwenk = 0;
		mat4 M_wobble = mat4(1);

		WindowManager* windowManager = nullptr;

		// Our shader program
		std::shared_ptr<Program> prog, progs, prog2, progsky, progg, prog_laser, prog_blur, progland;
		bool toogle_view = false;
		// Shape to be used (from obj file)
		shared_ptr<Shape> shape, sphere, sphere2;
		cityfieldelement_ cityfield[CITYSLOTS * 2 + 1][CITYSLOTS * 2 + 1];
		//camera


		//texture for sim
		GLuint TextureEarth, TexNoise, TexGod, TextureSky, TexLaser, g_cubeTexture, TexSuitMask, TexSuit, TexLensdirt, TexLaserMask;
		GLuint TextureF[6], FBOcolor, fb, FBO_blur, depth_rb, depth_blur , FBOviewpos, FBOworldnormal, FBOworldpos, FBOgodrays, FBOcolor_no_ssaa[2], FBOcolor_blurmap;
		GLuint Cube_framebuffer, Cube_depthbuffer, VBLasersPos, VBLasersCol, VAOLasers, VAOland;
		GLuint VAOlandsize;
		GLuint VertexArrayIDBox, VertexBufferIDBox, VertexBufferTex;

		// Contains vertex information for OpenGL
		GLuint VertexArrayID;

		// Data necessary to give our triangle to OpenGL
		GLuint VertexBufferID;

		void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)
			{
			if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
				{
				glfwSetWindowShouldClose(window, GL_TRUE);
				}
			if (key == GLFW_KEY_B && action == GLFW_RELEASE)
				{
				beattrigger = true;
				}

			if (key == GLFW_KEY_W && action == GLFW_PRESS)
				{
				mycam.w = 1;
				}
			if (key == GLFW_KEY_W && action == GLFW_RELEASE)
				{
				mycam.w = 0;
				}
			if (key == GLFW_KEY_S && action == GLFW_PRESS)
				{
				mycam.s = 1;
				}
			if (key == GLFW_KEY_S && action == GLFW_RELEASE)
				{
				mycam.s = 0;
				}
			if (key == GLFW_KEY_A && action == GLFW_PRESS)
				{
				mycam.a = 1;
				z_schwenk = -1;
				}
			if (key == GLFW_KEY_A && action == GLFW_RELEASE)
				{
				mycam.a = 0;
				z_schwenk = 0;
				}
			if (key == GLFW_KEY_D && action == GLFW_PRESS)
				{
				mycam.d = 1;
				z_schwenk = 1;
				}
			if (key == GLFW_KEY_D && action == GLFW_RELEASE)
				{
				mycam.d = 0;
				z_schwenk = 0;
				}
			if (key == GLFW_KEY_F && action == GLFW_RELEASE)
				{
				fullscreen = !fullscreen;
				}
			if (key == GLFW_KEY_SPACE && action == GLFW_RELEASE)
				{
				mycam.toggle();
				}
			if (key == GLFW_KEY_P && action == GLFW_RELEASE)
				{
				mycam.toggle_auto = !mycam.toggle_auto;
				}
			if (key == GLFW_KEY_ENTER && action == GLFW_RELEASE)
				{
				if (mycam.rot.z < 1)
					mycam.rot.z = 3.1415926;
				else
					mycam.rot.z = 0;
				}
			if (key == GLFW_KEY_F1)
				{
				rendermode = MODE_CITYFWD;
				mycam.reset();
				mycam.toggle_auto = true;
				}
			if (key == GLFW_KEY_F2)
				{
				rendermode = MODE_CITYSTATIC;				
				mycam.reset();
				mycam.rot.y = -0.4;
				mycam.oldrot.y = -0.4;
				}
			if (key == GLFW_KEY_F3)
				{
				rendermode = MODE_LANDFWD;
				mycam.reset();
				}
			if (key == GLFW_KEY_F3)
				{
				rendermode = MODE_LANDSTATIC;
				mycam.reset();
				}
			}
		void CreateCubeTexture()
			{
			glGenTextures(1, &g_cubeTexture);
			glBindTexture(GL_TEXTURE_CUBE_MAP, g_cubeTexture);

			glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_BASE_LEVEL, 0);
			glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAX_LEVEL, 0);
			glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
			glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
			glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
			glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

			std::vector<GLubyte> testData(CUBE_TEXTURE_SIZE * CUBE_TEXTURE_SIZE * 256, 128);
			std::vector<GLubyte> xData(CUBE_TEXTURE_SIZE * CUBE_TEXTURE_SIZE * 256, 255);

			for (int loop = 0; loop < 6; ++loop)
				{
				if (loop)
					{
					glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + loop, 0, GL_RGBA8,
								 CUBE_TEXTURE_SIZE, CUBE_TEXTURE_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, &testData[0]);
					}
				else
					{
					glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + loop, 0, GL_RGBA8,
								 CUBE_TEXTURE_SIZE, CUBE_TEXTURE_SIZE, 0, GL_RGBA, GL_UNSIGNED_BYTE, &xData[0]);
					}
				}

			glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
			}
		void mouseCallback(GLFWwindow * window, int button, int action, int mods)
			{
			double posX, posY;

			if (action == GLFW_PRESS)
				{
				glfwGetCursorPos(window, &posX, &posY);
				cout << "Pos X " << posX << " Pos Y " << posY << endl;
				}
			}

		void resizeCallback(GLFWwindow * window, int width, int height)
			{
			//remove all window size associated suff:

			glDeleteFramebuffers(1, &fb);
			glDeleteFramebuffers(1, &FBO_blur);


			glDeleteTextures(1, &FBOcolor);
			glDeleteTextures(1, &FBOviewpos);
			glDeleteTextures(1, &FBOworldpos);
			glDeleteTextures(1, &FBOgodrays);
			glDeleteTextures(1, &FBOworldnormal);
			glDeleteTextures(1, &FBOcolor_no_ssaa[0]);
			glDeleteTextures(1, &FBOcolor_no_ssaa[1]);
			glDeleteTextures(1, &FBOcolor_blurmap);

			glDeleteRenderbuffers(1, &depth_rb);
			glDeleteRenderbuffers(1, &depth_blur);

			generate_flexible_framebuffers();

			get_resolution(&width, &height);
			glViewport(0, 0, width, height);
			}
		void generate_flexible_framebuffers()
			{
			int width, height;
			get_resolution(&width, &height);

			//create frame buffer
			glGenFramebuffers(1, &fb);
			glActiveTexture(GL_TEXTURE0);
			glBindFramebuffer(GL_FRAMEBUFFER, fb);
			//RGBA8 2D texture, 24 bit depth texture, 256x256
			FBOcolor = generate_texture2D(GL_RGBA8, width * antialiasing, height * antialiasing, GL_RGBA, GL_UNSIGNED_BYTE, NULL, GL_CLAMP_TO_BORDER, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
			FBOviewpos = generate_texture2D(GL_RGBA32F, width * antialiasing, height * antialiasing, GL_RGBA, GL_FLOAT, NULL, GL_REPEAT, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
			FBOworldpos = generate_texture2D(GL_RGBA32F, width * antialiasing, height * antialiasing, GL_RGBA, GL_FLOAT, NULL, GL_REPEAT, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
			FBOgodrays = generate_texture2D(GL_RGBA8, width * antialiasing, height * antialiasing, GL_RGBA, GL_UNSIGNED_BYTE, NULL, GL_REPEAT, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
			FBOworldnormal = generate_texture2D(GL_RGBA32F, width * antialiasing, height * antialiasing, GL_RGBA, GL_FLOAT, NULL, GL_REPEAT, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
			//Attach 2D texture to this FBO
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, FBOcolor, 0);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, FBOviewpos, 0);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, FBOworldpos, 0);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT3, GL_TEXTURE_2D, FBOworldnormal, 0);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT4, GL_TEXTURE_2D, FBOgodrays, 0);
			//create depth buffer
			glGenRenderbuffers(1, &depth_rb);
			glBindRenderbuffer(GL_RENDERBUFFER, depth_rb);
			glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT32, width * antialiasing, height * antialiasing);
			//Attach depth buffer to FBO
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depth_rb);
			//-------------------------
			glBindFramebuffer(GL_FRAMEBUFFER, 0);



			//create frame buffer for two step blur
			glGenFramebuffers(1, &FBO_blur);
			glBindFramebuffer(GL_FRAMEBUFFER, FBO_blur);
			FBOcolor_no_ssaa[0] = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, NULL, GL_CLAMP_TO_BORDER, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
			FBOcolor_no_ssaa[1] = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, NULL, GL_CLAMP_TO_BORDER, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
			FBOcolor_blurmap = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, NULL, GL_CLAMP_TO_BORDER, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, FBOcolor_no_ssaa[0], 0);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, FBOcolor_blurmap, 0);

			glGenRenderbuffers(1, &depth_blur);
			glBindRenderbuffer(GL_RENDERBUFFER, depth_blur);
			glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, width, height);
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depth_blur);
			glBindFramebuffer(GL_FRAMEBUFFER, 0);
			//*******************************************************************************************************

			}
		void init(const std::string & resourceDirectory)
			{


			GLSL::checkVersion();


			// Set background color.
			glClearColor(0.12f, 0.34f, 0.56f, 1.0f);

			// Enable z-buffer test.
			glEnable(GL_DEPTH_TEST);

			//culling:
			glEnable(GL_CULL_FACE);
			glFrontFace(GL_CCW);

			//transparency
			glEnable(GL_BLEND);
			//next function defines how to mix the background color with the transparent pixel in the foreground. 
			//This is the standard:
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

			// Initialize the GLSL program.
			prog = make_shared<Program>();
			prog->setVerbose(true);
			prog->setShaderNames(resourceDirectory + "/instance_vert.glsl", resourceDirectory + "/simple_frag.glsl");
			if (!prog->init())
				{
				std::cerr << "One or more shaders failed to compile... exiting!" << std::endl;
				exit(1);
				}
			prog->addUniform("freq_ampl");
			prog->addUniform("P");
			prog->addUniform("V");
			prog->addUniform("M");
			prog->addUniform("reflection_on");
			prog->addUniform("render_lines");
			prog->addUniform("campos");
			prog->addAttribute("vertPos");
			prog->addAttribute("vertNor");
			prog->addAttribute("vertTex");


			progs = make_shared<Program>();
			progs->setVerbose(true);
			progs->setShaderNames(resourceDirectory + "/simple_vert.glsl", resourceDirectory + "/suit_frag.glsl");
			if (!progs->init())
				{
				std::cerr << "One or more shaders failed to compile... exiting!" << std::endl;
				exit(1);
				}

			progs->addUniform("P");
			progs->addUniform("V");
			progs->addUniform("M");
			progs->addUniform("reflection_on");
			progs->addUniform("campos");
			progs->addAttribute("vertPos");
			progs->addAttribute("vertNor");
			progs->addAttribute("vertTex");
			progs->addUniform("render_lines");



			prog2 = make_shared<Program>();
			prog2->setVerbose(true);
			prog2->setShaderNames(resourceDirectory + "/vert.glsl", resourceDirectory + "/frag_nolight.glsl");
			if (!prog2->init())
				{
				std::cerr << "One or more shaders failed to compile... exiting!" << std::endl;
				exit(1);
				}

			prog2->addUniform("P");
			prog2->addUniform("V");
			prog2->addUniform("M");
			prog2->addUniform("speed");
			prog2->addAttribute("vertPos");
			prog2->addAttribute("vertTex");
			prog2->addUniform("Pcam");
			prog2->addUniform("Vcam");
			prog2->addUniform("windows_size");


			prog_blur = make_shared<Program>();
			prog_blur->setVerbose(true);
			prog_blur->setShaderNames(resourceDirectory + "/vert.glsl", resourceDirectory + "/blur_frag.glsl");
			if (!prog_blur->init())
				{
				std::cerr << "One or more shaders failed to compile... exiting!" << std::endl;
				exit(1);
				}
			prog_blur->addUniform("P");
			prog_blur->addUniform("V");
			prog_blur->addUniform("M");
			prog_blur->addAttribute("vertPos");
			prog_blur->addAttribute("vertTex");
			prog_blur->addUniform("speed");
			prog_blur->addUniform("Pcam");
			prog_blur->addUniform("Vcam");
			prog_blur->addUniform("stepno");
			prog_blur->addUniform("viewmode");
			prog_blur->addUniform("windows_size");



			progsky = make_shared<Program>();
			progsky->setVerbose(true);
			progsky->setShaderNames(resourceDirectory + "/vert.glsl", resourceDirectory + "/sky_frag.glsl");
			if (!progsky->init())
				{
				std::cerr << "One or more shaders failed to compile... exiting!" << std::endl;
				exit(1);
				}
			progsky->addUniform("P");
			progsky->addUniform("V");
			progsky->addUniform("M");
			progsky->addAttribute("vertPos");
			progsky->addAttribute("vertTex");

			progland = make_shared<Program>();
			progland->setVerbose(true);
			progland->setShaderNames(resourceDirectory + "/vert.glsl", resourceDirectory + "/land_frag.glsl");
			if (!progland->init())
				{
				std::cerr << "One or more shaders failed to compile... exiting!" << std::endl;
				exit(1);
				}
			progland->addUniform("P");
			progland->addUniform("V");
			progland->addUniform("M");
			progland->addAttribute("vertPos");
			progland->addAttribute("vertTex");

			progg = make_shared<Program>();
			progg->setVerbose(true);
			progg->setShaderNames(resourceDirectory + "/vert.glsl", resourceDirectory + "/ground_frag.glsl");
			if (!progg->init())
				{
				std::cerr << "One or more shaders failed to compile... exiting!" << std::endl;
				exit(1);
				}
			progg->addUniform("P");
			progg->addUniform("V");
			progg->addUniform("M");
			progg->addAttribute("vertPos");
			progg->addAttribute("vertTex");


			prog_laser = make_shared<Program>();
			prog_laser->setVerbose(true);
			prog_laser->setShaderNames(resourceDirectory + "/vert_laser.glsl", resourceDirectory + "/laser_frag.glsl", resourceDirectory + "/geometry_laser.glsl");
			if (!prog_laser->init())
				{
				std::cerr << "One or more shaders failed to compile... exiting!" << std::endl;
				exit(1);
				}
			prog_laser->addUniform("P");
			prog_laser->addUniform("V");
			prog_laser->addUniform("M");
			prog_laser->addAttribute("vertPos");
			prog_laser->addAttribute("vertCol");


			}
		GLuint generate_texture2D(GLushort colortype, int width, int height, GLushort colororder, GLushort datatype, BYTE * data, GLushort wrap, GLushort minfilter, GLushort magfilter)
			{
			GLuint textureID;
			//RGBA8 2D texture, 24 bit depth texture, 256x256
			glGenTextures(1, &textureID);
			glBindTexture(GL_TEXTURE_2D, textureID);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minfilter);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magfilter);
			glTexImage2D(GL_TEXTURE_2D, 0, colortype, width, height, 0, colororder, datatype, data);
			glGenerateMipmap(GL_TEXTURE_2D);
			return textureID;
			}
		//**************************************************************************************************************************************************
#define LANDSIZE 20
		void init_land()
			{
			GLuint VB;
			glGenVertexArrays(1, &VAOland);
			glBindVertexArray(VAOland);			
			glGenBuffers(1, &VB);
			glBindBuffer(GL_ARRAY_BUFFER, VB);
			vector<vec3> pos;
			//front to back
			for (int ii = -LANDSIZE / 2; ii < +LANDSIZE / 2; ii++)
				{
				pos.push_back(vec3(-LANDSIZE, -2, ii));
				pos.push_back(vec3(+LANDSIZE, -2, ii));
				}
			//left to right
			for (int ii = -LANDSIZE / 2; ii < +LANDSIZE / 2; ii++)
				{
				pos.push_back(vec3(ii, -2, -LANDSIZE));
				pos.push_back(vec3(ii, -2, +LANDSIZE));
				}
			glBufferData(GL_ARRAY_BUFFER, sizeof(vec2) * pos.size(), pos.data(), GL_STATIC_DRAW);
			VAOlandsize = pos.size();
			glEnableVertexAttribArray(0);
			glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
			glBindVertexArray(0);
			}
		//**************************************************************************************************************************************************
		void initGeom(const std::string & resourceDirectory)
			{
			//lasers:
			glGenVertexArrays(1, &VAOLasers);
			glBindVertexArray(VAOLasers);
			glGenBuffers(1, &VBLasersPos);
			glBindBuffer(GL_ARRAY_BUFFER, VBLasersPos);
			vec3 posi[MAXLASERS];
			for (int i = 0; i < MAXLASERS; i++)
				posi[i] = vec3(i * 3, 0, -3);
			glBufferData(GL_ARRAY_BUFFER, sizeof(vec3) * MAXLASERS, posi, GL_DYNAMIC_DRAW);
			glEnableVertexAttribArray(0);
			glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

			glGenBuffers(1, &VBLasersCol);
			glBindBuffer(GL_ARRAY_BUFFER, VBLasersCol);
			vec3 lascol[MAXLASERS];

			for (int i = 0; i < MAXLASERS; i++)
				lascol[i] = vec3(0);
			glBufferData(GL_ARRAY_BUFFER, sizeof(vec3) * MAXLASERS, lascol, GL_DYNAMIC_DRAW);
			glEnableVertexAttribArray(1);
			glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

			glBindVertexArray(0);
			//------------------------------------------------


			for (int i = 0; i < 10; i++)
				{
				amplitude_on_frequency_10steps[i] = 0;
				}
			//init rectangle mesh (2 triangles) for the post processing
			glGenVertexArrays(1, &VertexArrayIDBox);
			glBindVertexArray(VertexArrayIDBox);

			//generate vertex buffer to hand off to OGL
			glGenBuffers(1, &VertexBufferIDBox);
			//set the current state to focus on our vertex buffer
			glBindBuffer(GL_ARRAY_BUFFER, VertexBufferIDBox);

			GLfloat* rectangle_vertices = new GLfloat[18];
			// front
			int verccount = 0;

			rectangle_vertices[verccount++] = -1.0, rectangle_vertices[verccount++] = -1.0, rectangle_vertices[verccount++] = 0.0;
			rectangle_vertices[verccount++] = 1.0, rectangle_vertices[verccount++] = -1.0, rectangle_vertices[verccount++] = 0.0;
			rectangle_vertices[verccount++] = -1.0, rectangle_vertices[verccount++] = 1.0, rectangle_vertices[verccount++] = 0.0;
			rectangle_vertices[verccount++] = 1.0, rectangle_vertices[verccount++] = -1, rectangle_vertices[verccount++] = 0.0;
			rectangle_vertices[verccount++] = 1.0, rectangle_vertices[verccount++] = 1.0, rectangle_vertices[verccount++] = 0.0;
			rectangle_vertices[verccount++] = -1.0, rectangle_vertices[verccount++] = 1.0, rectangle_vertices[verccount++] = 0.0;


			//actually memcopy the data - only do this once
			glBufferData(GL_ARRAY_BUFFER, 18 * sizeof(float), rectangle_vertices, GL_STATIC_DRAW);
			//we need to set up the vertex array
			glEnableVertexAttribArray(0);
			//key function to get up how many elements to pull out at a time (3)
			glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);


			//generate vertex buffer to hand off to OGL
			glGenBuffers(1, &VertexBufferTex);
			//set the current state to focus on our vertex buffer
			glBindBuffer(GL_ARRAY_BUFFER, VertexBufferTex);

			float t = 1. / 100.;
			GLfloat* rectangle_texture_coords = new GLfloat[12];
			int texccount = 0;
			rectangle_texture_coords[texccount++] = 0, rectangle_texture_coords[texccount++] = 0;
			rectangle_texture_coords[texccount++] = 1, rectangle_texture_coords[texccount++] = 0;
			rectangle_texture_coords[texccount++] = 0, rectangle_texture_coords[texccount++] = 1;
			rectangle_texture_coords[texccount++] = 1, rectangle_texture_coords[texccount++] = 0;
			rectangle_texture_coords[texccount++] = 1, rectangle_texture_coords[texccount++] = 1;
			rectangle_texture_coords[texccount++] = 0, rectangle_texture_coords[texccount++] = 1;

			//actually memcopy the data - only do this once
			glBufferData(GL_ARRAY_BUFFER, 12 * sizeof(float), rectangle_texture_coords, GL_STATIC_DRAW);
			//we need to set up the vertex array
			glEnableVertexAttribArray(2);
			//key function to get up how many elements to pull out at a time (3)
			glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);

			sphere2 = make_shared<Shape>();
			sphere2->loadMesh(resourceDirectory + "/armor2.obj");
			sphere2->resize();
			sphere2->init();

			sphere = make_shared<Shape>();
			//sphere->loadMesh(resourceDirectory + "/sky.obj");
			sphere->loadMesh(resourceDirectory + "/sphere.obj");
			sphere->resize();
			sphere->init();
			// Initialize mesh.
			shape = make_shared<Shape>();
			shape->loadMesh(resourceDirectory + "/buildings3.obj");
			shape->resize_subobj();
			float abst = BULDINGDIST;
			int instancesize = shape->return_subsize();
			vector<float> * instancepos = new vector<float>[instancesize];

			for (int xx = -CITYSLOTS; xx < CITYSLOTS; xx++)
				for (int zz = -CITYSLOTS; zz < CITYSLOTS; zz++)
					{
					float height = (float)rand() / 32768.;
					height = pow(height, 20);
					height *= 5;
					if (height < 0.5) height = 0.5;
					/*height = 8;

					if (xx < 5) height = 0.1;
					if (zz>-5 && zz < 5) height = 0.1;*/
					int house = rand() % instancesize;
					/*if (xx < -5)
						{
						house = 1;
						height = 8;
						}
					else if(xx>5)
						{
						house = 2;
						height = 4;
						}
					else
						{
						house = 1;
						height = 0.1;
						}*/
					if (xx == 0) height = min(2.0, height);
					if (xx == 1) height = min(2.0, height);
					if (xx == -1) height = min(2.0, height);
					instancepos[house].push_back(xx * abst);
					instancepos[house].push_back(height);
					instancepos[house].push_back(zz * abst);
					instancepos[house].push_back(rand() % 6);
					cityfield[xx + CITYSLOTS][zz + CITYSLOTS].height = height;
					}
			init_laser();
			for (int ii = 0; ii < shape->return_subsize(); ii++)
				{
				shape->init(ii, true, 3, &instancepos[ii]);
				}
			delete[] instancepos;
			int width, height, channels;
			char filepath[1000];

			//texture earth diffuse
			string str = resourceDirectory + "/sky.jpg";
			str = resourceDirectory + "/sunsets4.jpg";
			strcpy(filepath, str.c_str());
			unsigned char* data = stbi_load(filepath, &width, &height, &channels, 4);
			TextureSky = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_MIRRORED_REPEAT, GL_LINEAR, GL_LINEAR);
			//texture earth diffuse
			str = resourceDirectory + "/skyscraperBG.jpg";
			strcpy(filepath, str.c_str());
			data = stbi_load(filepath, &width, &height, &channels, 4);
			TextureEarth = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_REPEAT, GL_LINEAR, GL_LINEAR);
			//texture earth diffuse
			str = resourceDirectory + "/laser2.tga";
			strcpy(filepath, str.c_str());
			data = stbi_load(filepath, &width, &height, &channels, 4);
			TexLaser = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_REPEAT, GL_LINEAR, GL_LINEAR);
			//texture earth diffuse
			str = resourceDirectory + "/lensdirt5.jpg";
			strcpy(filepath, str.c_str());
			data = stbi_load(filepath, &width, &height, &channels, 4);
			TexLensdirt = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_REPEAT, GL_LINEAR, GL_LINEAR);
			//texture earth diffuse
			str = resourceDirectory + "/noise.jpg";
			strcpy(filepath, str.c_str());
			data = stbi_load(filepath, &width, &height, &channels, 4);
			TexNoise = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_REPEAT, GL_LINEAR, GL_LINEAR);
			//texture earth diffuse
			str = resourceDirectory + "/sunsetsgod.jpg";
			strcpy(filepath, str.c_str());
			data = stbi_load(filepath, &width, &height, &channels, 4);
			TexGod = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_MIRRORED_REPEAT, GL_LINEAR, GL_LINEAR);
			//texture earth diffuse
			str = resourceDirectory + "/masklaser.jpg";
			strcpy(filepath, str.c_str());
			data = stbi_load(filepath, &width, &height, &channels, 4);
			TexLaserMask = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_CLAMP_TO_EDGE, GL_LINEAR, GL_LINEAR);
			//texture earth diffuse
			str = resourceDirectory + "/texturesuit.jpg";
			strcpy(filepath, str.c_str());
			data = stbi_load(filepath, &width, &height, &channels, 4);
			TexSuit = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_REPEAT, GL_LINEAR, GL_LINEAR);
			//texture earth diffuse
			str = resourceDirectory + "/mask.jpg";
			strcpy(filepath, str.c_str());
			data = stbi_load(filepath, &width, &height, &channels, 4);
			TexSuitMask = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_REPEAT, GL_LINEAR, GL_LINEAR);

			//texture front
			for (int ii = 0; ii < 6; ii++)
				{
				char text[1000];
				sprintf(text, "%s/skyscraperF%d.jpg", resourceDirectory.c_str(), ii + 1);
				str = text;
				strcpy(filepath, str.c_str());
				data = stbi_load(filepath, &width, &height, &channels, 4);
				TextureF[ii] = generate_texture2D(GL_RGBA8, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data, GL_REPEAT, GL_LINEAR, GL_LINEAR);
				}
			//[TWOTEXTURES]
			//set the 2 textures to the correct samplers in the fragment shader:
			GLuint Tex1Location = glGetUniformLocation(prog->pid, "tex");//tex, tex2... sampler in the fragment shader
			GLuint Tex2Location = glGetUniformLocation(prog->pid, "tex2");
			// Then bind the uniform samplers to texture units:
			glUseProgram(prog->pid);
			glUniform1i(Tex1Location, 0);
			glUniform1i(Tex2Location, 1);


			generate_flexible_framebuffers();



			//create frame buffer for cube map
			glGenFramebuffers(1, &Cube_framebuffer);
			glActiveTexture(GL_TEXTURE0);
			glBindFramebuffer(GL_FRAMEBUFFER, Cube_framebuffer);
			//create depth buffer
			glGenRenderbuffers(1, &Cube_depthbuffer);
			glBindRenderbuffer(GL_RENDERBUFFER, Cube_depthbuffer);
			glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, CUBE_TEXTURE_SIZE, CUBE_TEXTURE_SIZE);
			//Attach depth buffer to FBO
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, Cube_depthbuffer);
			glBindFramebuffer(GL_FRAMEBUFFER, 0);
			CreateCubeTexture();
			//-------------------------

			//Does the GPU support current FBO configuration?
			glUseProgram(prog->pid);
			int TexLoc = glGetUniformLocation(prog->pid, "tex");		glUniform1i(TexLoc, 0);
			TexLoc = glGetUniformLocation(prog->pid, "tex1");			glUniform1i(TexLoc, 1);
			TexLoc = glGetUniformLocation(prog->pid, "tex2");			glUniform1i(TexLoc, 2);
			TexLoc = glGetUniformLocation(prog->pid, "tex3");			glUniform1i(TexLoc, 3);
			TexLoc = glGetUniformLocation(prog->pid, "tex4");			glUniform1i(TexLoc, 4);
			TexLoc = glGetUniformLocation(prog->pid, "tex5");			glUniform1i(TexLoc, 5);
			TexLoc = glGetUniformLocation(prog->pid, "tex6");			glUniform1i(TexLoc, 6);
			TexLoc = glGetUniformLocation(prog->pid, "skytex");			glUniform1i(TexLoc, 7);
			TexLoc = glGetUniformLocation(prog->pid, "skycube");
			glUniform1i(TexLoc, 8);

			glUseProgram(progs->pid);
			TexLoc = glGetUniformLocation(progs->pid, "tex");			glUniform1i(TexLoc, 0);
			TexLoc = glGetUniformLocation(progs->pid, "tex1");			glUniform1i(TexLoc, 1);
			TexLoc = glGetUniformLocation(progs->pid, "skycube");		glUniform1i(TexLoc, 8);

			glUseProgram(progsky->pid);
			TexLoc = glGetUniformLocation(progsky->pid, "tex");			glUniform1i(TexLoc, 0);
			TexLoc = glGetUniformLocation(progsky->pid, "texgod");		glUniform1i(TexLoc, 1);

			glUseProgram(prog_laser->pid);
			TexLoc = glGetUniformLocation(prog_laser->pid, "tex");		glUniform1i(TexLoc, 0);
			TexLoc = glGetUniformLocation(prog_laser->pid, "mask");		glUniform1i(TexLoc, 1);

			glUseProgram(prog_blur->pid);
			TexLoc = glGetUniformLocation(prog_blur->pid, "colortex");		glUniform1i(TexLoc, 0);
			TexLoc = glGetUniformLocation(prog_blur->pid, "blurmap");		glUniform1i(TexLoc, 1);

			glUseProgram(prog2->pid);
			TexLoc = glGetUniformLocation(prog2->pid, "tex");			glUniform1i(TexLoc, 0);
			TexLoc = glGetUniformLocation(prog2->pid, "viewpos");		glUniform1i(TexLoc, 1);
			TexLoc = glGetUniformLocation(prog2->pid, "worldpos");		glUniform1i(TexLoc, 2);
			TexLoc = glGetUniformLocation(prog2->pid, "worldnormal");	glUniform1i(TexLoc, 3);
			TexLoc = glGetUniformLocation(prog2->pid, "noise");			glUniform1i(TexLoc, 4);
			TexLoc = glGetUniformLocation(prog2->pid, "skygod");		glUniform1i(TexLoc, 5);
			TexLoc = glGetUniformLocation(prog2->pid, "lensdirt");		glUniform1i(TexLoc, 6);
			TexLoc = glGetUniformLocation(prog2->pid, "skycube");		glUniform1i(TexLoc, 7);

			GLenum status;
			status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
			switch (status)
				{
				case GL_FRAMEBUFFER_COMPLETE:
				cout << "status framebuffer: good";
				break;
				default:
				cout << "status framebuffer: bad!!!!!!!!!!!!!!!!!!!!!!!!!";
				}
			glBindFramebuffer(GL_FRAMEBUFFER, 0);


			}
		//*************************************
		double get_last_elapsed_time()
			{
			static double lasttime = glfwGetTime();
			double actualtime = glfwGetTime();
			double difference = actualtime - lasttime;
			lasttime = actualtime;
			return difference;
			}

		//*************************************
		void render_to_screen()
			{
			glBindFramebuffer(GL_FRAMEBUFFER, FBO_blur);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, FBOcolor_no_ssaa[0], 0);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, FBOcolor_blurmap, 0);
			GLenum buffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };
			glDrawBuffers(2, buffers);

			//glBindFramebuffer(GL_FRAMEBUFFER, 0);

			// Get current frame buffer size.
			int width, height;
			get_resolution(&width, &height);
	
			glViewport(0, 0, width, height);


			glm::mat4 M, V, S, T;

			prog2->bind();

			V = glm::mat4(1);

			mat4 Vcam = mycam.V;
			mat4 Pcam = glm::perspective((float)(3.14159 / 3.), (float)((float)width / (float)height), 0.1f, 100.0f); //so much type casting... GLM metods are quite funny ones
			glUniformMatrix4fv(prog2->getUniform("Pcam"), 1, GL_FALSE, &Pcam[0][0]);
			glUniformMatrix4fv(prog2->getUniform("Vcam"), 1, GL_FALSE, &Vcam[0][0]);

			glUniform1f(prog2->getUniform("speed"), mycam.get_speed());

			// Clear framebuffer.


			glClearColor(0.0, 0.0, 0.0, 1.0);
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


			glActiveTexture(GL_TEXTURE0);		glBindTexture(GL_TEXTURE_2D, FBOcolor);
			glActiveTexture(GL_TEXTURE1);		glBindTexture(GL_TEXTURE_2D, FBOviewpos);
			glActiveTexture(GL_TEXTURE2);		glBindTexture(GL_TEXTURE_2D, FBOworldpos);
			glActiveTexture(GL_TEXTURE3);		glBindTexture(GL_TEXTURE_2D, FBOworldnormal);
			glActiveTexture(GL_TEXTURE4);		glBindTexture(GL_TEXTURE_2D, TexNoise);
			glActiveTexture(GL_TEXTURE5);		glBindTexture(GL_TEXTURE_2D, FBOgodrays);
			glActiveTexture(GL_TEXTURE6);		glBindTexture(GL_TEXTURE_2D, TexLensdirt);
			glActiveTexture(GL_TEXTURE7);		glBindTexture(GL_TEXTURE_CUBE_MAP, g_cubeTexture);

			V = glm::mat4(1);
		
			glUniformMatrix4fv(prog2->getUniform("P"), 1, GL_FALSE, &V[0][0]);
			glUniformMatrix4fv(prog2->getUniform("V"), 1, GL_FALSE, &V[0][0]);
			glUniformMatrix4fv(prog2->getUniform("M"), 1, GL_FALSE, &V[0][0]);
			vec2 winsize = vec2(width, height);
			glUniform2fv(prog2->getUniform("windows_size"), 1, &winsize.x);
			glBindVertexArray(VertexArrayIDBox);
			glDrawArrays(GL_TRIANGLES, 0, 6);

			prog2->unbind();
			glBindTexture(GL_TEXTURE_2D, FBOcolor_no_ssaa[0]);
			glGenerateMipmap(GL_TEXTURE_2D);
			glBindTexture(GL_TEXTURE_2D, FBOcolor_blurmap);
			glGenerateMipmap(GL_TEXTURE_2D);
			}
		//*****************************************************************************************************************************************************************************
		void render_blur_n_screen(double frametime, int step) // aka render to framebuffer
			{
			
			if (step == 0)
				{
				glBindFramebuffer(GL_FRAMEBUFFER, FBO_blur);
				glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, FBOcolor_no_ssaa[1], 0);
				GLenum buffers[] = { GL_COLOR_ATTACHMENT0 };
				glDrawBuffers(1, buffers);
				}
			else
				{
				glBindFramebuffer(GL_FRAMEBUFFER, 0);
				}

			
			

			glClearColor(1.0, 0.0, 0.0, 1.0);
			int width, height;
			get_resolution(&width, &height); 

			int realwidth, realheight;
			glfwGetFramebufferSize(windowManager->getHandle(), &realwidth, &realheight);
			if (step == 1)glViewport(0, 0, realwidth, realheight);
			
			glm::mat4 V = mat4(1), P = mat4(1);

			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

			prog_blur->bind();

			V = glm::mat4(1);

			mat4 Vcam = mycam.V;
			mat4 Pcam = glm::perspective((float)(3.14159 / 3.), (float)((float)width / (float)height), 0.1f, 100.0f); //so much type casting... GLM metods are quite funny ones
			glUniformMatrix4fv(prog_blur->getUniform("Pcam"), 1, GL_FALSE, &Pcam[0][0]);
			glUniformMatrix4fv(prog_blur->getUniform("Vcam"), 1, GL_FALSE, &Vcam[0][0]);
			glUniform1f(prog_blur->getUniform("speed"), mycam.get_speed());
			glUniform1f(prog_blur->getUniform("stepno"), (float)step);
			glUniform1f(prog_blur->getUniform("viewmode"), (float)mycam.toggleview);
			vec2 winsize = vec2(width, height);
			glUniform2fv(prog_blur->getUniform("windows_size"),1, &winsize.x);
			glUniformMatrix4fv(prog_blur->getUniform("P"), 1, GL_FALSE, &V[0][0]);
			glUniformMatrix4fv(prog_blur->getUniform("V"), 1, GL_FALSE, &V[0][0]);
			glUniformMatrix4fv(prog_blur->getUniform("M"), 1, GL_FALSE, &V[0][0]);

			glActiveTexture(GL_TEXTURE0);		glBindTexture(GL_TEXTURE_2D, FBOcolor_no_ssaa[step]);
			glActiveTexture(GL_TEXTURE1);		glBindTexture(GL_TEXTURE_2D, FBOcolor_blurmap);

			glBindVertexArray(VertexArrayIDBox);
			glDrawArrays(GL_TRIANGLES, 0, 6);

			prog_blur->unbind();

			/*if (step == 0)
				{
				glBindFramebuffer(GL_FRAMEBUFFER, 0);
				glBindTexture(GL_TEXTURE_2D, FBOcolor_no_ssaa[1]);
				glGenerateMipmap(GL_TEXTURE_2D);
				}		*/
			}
		//*************************************
		void aquire_fft_scaling_arrays()
			{
			//get FFT array
			static int length = 0;
			if (fft(amplitude_on_frequency, length))
				{
				//put the height of the frequencies 20Hz to 20000Hz into the height of the line-vertices
				vec3 vertices[FFT_MAXSIZE];

				float oldval[10];
				//calculate the average amplitudes for the 10 spheres
				for (int i = 0; i < 10; i++)
					{
					oldval[i] = amplitude_on_frequency_10steps[i];

					amplitude_on_frequency_10steps[i] = 0;
					}
				int mean_range = length / 10;
				int bar = 0;
				int count = 0;
				mean_range = 1;
				for (int i = 0; ; i++, count++)
					{
					if (mean_range == count)
						{
						count = -1;
						amplitude_on_frequency_10steps[bar] /= (float)mean_range;
						bar++;
						mean_range++;
						if (bar == 10)break;
						}
					if (i < length && i < FFT_MAXSIZE)
						amplitude_on_frequency_10steps[bar] += amplitude_on_frequency[i];
					}

				for (int i = 0; i < 10; i++)
					amplitude_on_frequency_10steps[i] = delayfilter(oldval[i], amplitude_on_frequency_10steps[i], 1.02);
				}

			//	cout << amplitude_on_frequency_10steps[0] << endl;
			}
		//************************************************************************************************
		void update_wobble_pilot(double frametime)
			{
			if (rendermode != MODE_CITYFWD) return;
			static float Ax = 1, Ay = 1, Az = 1;
			static vec3 Periods = vec3(1);
			static vec3 totalperiod = vec3(0);
			totalperiod += Periods * (float)frametime * (float)3.2;

			if (totalperiod.x <= 0.00001 || totalperiod.x >= 3.1415926)
				{
				Periods.x = 0.5 + frand();
				float newAx = (frand() + 0.6) * 0.00027;
				if (Ax > 0)newAx *= -1;
				Ax = newAx;
				totalperiod.x = 0;
				}

			if (totalperiod.y <= 0.00001 || totalperiod.y >= 3.1415926)
				{
				Periods.y = 0.5 + frand();
				float newAy = (frand() + 0.6) * 0.00027;
				if (Ay > 0)newAy *= -1;
				Ay = newAy;
				totalperiod.y = 0;
				}

			if (totalperiod.z <= 0.00001 || totalperiod.z >= 3.1415926)
				{
				Periods.z = 0.5 + frand();
				float newAz = (frand() + 0.2) * 0.03;
				if (Ax > 0)newAz *= -1;
				Az = newAz;
				totalperiod.z = 0;
				}


			vec3 wobble;
			wobble.x = sin(totalperiod.x) * Ax;
			wobble.y = sin(totalperiod.y) * Ay;
			wobble.z = sin(totalperiod.z) * Az;
			mat4 VT = translate(mat4(1), vec3(wobble.x, wobble.y, 0));
			mat4 VRz = rotate(mat4(1), wobble.z, vec3(0, 0, 1));

			M_wobble = VT * VRz;






			}
		//************************************************************************************************	
		void render_citypilot(int width, int height, mat4 P, mat4 V, bool pilotrender, double frametime)
			{

			float mul_scale = CITYMULSCALE;

			glClearColor(0.0, 0.0, 0.0, 0.0);
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
			// Get current frame buffer size.

			glViewport(0, 0, width, height);

			glm::mat4 M, S, T;

			float pih = -3.1415926 / 2.0;
			glm::mat4 Rx = glm::rotate(glm::mat4(1.f), pih, glm::vec3(1, 0, 0));

			//	******		skysphere		******

			glFrontFace(GL_CW);
			glDisable(GL_DEPTH_TEST);

			glm::mat4 RxSun = glm::rotate(glm::mat4(1.f), (float)(3.1415926 * 0.5), glm::vec3(1, 0, 0));
			glm::mat4 RySun = glm::rotate(glm::mat4(1.f), (float)(-3.1415926 * 0.5 + 0.8), glm::vec3(0, 1, 0));
			T = glm::translate(glm::mat4(1.f), glm::vec3(mycam.pos));
			S = glm::scale(glm::mat4(1.f), glm::vec3(100.1, 100.1, 100.1));

			progsky->bind();

			glActiveTexture(GL_TEXTURE0);			glBindTexture(GL_TEXTURE_2D, TextureSky);
			glActiveTexture(GL_TEXTURE1);			glBindTexture(GL_TEXTURE_2D, TexGod);

			glUniformMatrix4fv(progsky->getUniform("P"), 1, GL_FALSE, &P[0][0]);
			glUniformMatrix4fv(progsky->getUniform("V"), 1, GL_FALSE, &V[0][0]);
			float ww = (2. * 3.1415926) / 8.;

			mat4 MM = T * RySun * RxSun * S;
			glUniformMatrix4fv(progsky->getUniform("M"), 1, GL_FALSE, &MM[0][0]);
			sphere->draw(prog, true);	//draw sky

			progsky->unbind();

			//****************boden********************
			progg->bind();
			glUniformMatrix4fv(progg->getUniform("P"), 1, GL_FALSE, &P[0][0]);
			glUniformMatrix4fv(progg->getUniform("V"), 1, GL_FALSE, &V[0][0]);
			for (int ii = 0; ii < 2; ii++)
				{
				M = translate(mat4(1), vec3(0, -40, -ii * CITYMULSCALE * CITYSIZE)) * glm::rotate(glm::mat4(1), (float)(3.1415926 * 0.5), glm::vec3(1, 0, 0)) * glm::scale(glm::mat4(1), glm::vec3(CITYSIZE * CITYMULSCALE * 0.5, CITYSIZE * CITYMULSCALE * 0.5, 1));
				//M = translate(mat4(1), vec3(0, 0, -4+ii*8))* glm::scale(glm::mat4(1), glm::vec3(20,20,20));
				glUniformMatrix4fv(progg->getUniform("M"), 1, GL_FALSE, &M[0][0]);
				glBindVertexArray(VertexArrayIDBox);
				glDrawArrays(GL_TRIANGLES, 0, 6);
				}
			progg->unbind();
			//**************** ENDE boden*********************
			glFrontFace(GL_CCW);
			glEnable(GL_DEPTH_TEST);




			//bind shader and copy matrices
			prog->bind();

			glUniform1f(prog->getUniform("reflection_on"), 0.0);

			glUniformMatrix4fv(prog->getUniform("P"), 1, GL_FALSE, &P[0][0]);
			glUniformMatrix4fv(prog->getUniform("V"), 1, GL_FALSE, &V[0][0]);
			glUniform3fv(prog->getUniform("campos"), 1, &mycam.pos.x);

			//	******		buildings		******
			glActiveTexture(GL_TEXTURE0);
			glBindTexture(GL_TEXTURE_2D, TextureEarth);
			glActiveTexture(GL_TEXTURE1);		glBindTexture(GL_TEXTURE_2D, TextureF[0]);
			glActiveTexture(GL_TEXTURE2);		glBindTexture(GL_TEXTURE_2D, TextureF[1]);
			glActiveTexture(GL_TEXTURE3);		glBindTexture(GL_TEXTURE_2D, TextureF[2]);
			glActiveTexture(GL_TEXTURE4);		glBindTexture(GL_TEXTURE_2D, TextureF[3]);
			glActiveTexture(GL_TEXTURE5);		glBindTexture(GL_TEXTURE_2D, TextureF[4]);
			glActiveTexture(GL_TEXTURE6);		glBindTexture(GL_TEXTURE_2D, TextureF[5]);
			glActiveTexture(GL_TEXTURE7);		glBindTexture(GL_TEXTURE_2D, TextureSky);
			glActiveTexture(GL_TEXTURE8);		glBindTexture(GL_TEXTURE_CUBE_MAP, g_cubeTexture);
			glUniform1fv(prog->getUniform("freq_ampl"), 10, amplitude_on_frequency_10steps);
			//cout << amplitude_on_frequency_10steps[3] << endl;

		

			float offset_z = 0;
			int parts = (int)mycam.pos.z / (CITYSIZE * mul_scale);
			offset_z = parts * (CITYSIZE * mul_scale);
			if (parts != 0)
				{
				mycam.pos.z -= offset_z;
				}
			
			for (int ii = 0; ii < 2; ii++)
				{
				M = glm::translate(glm::mat4(1.f), glm::vec3(0, -2.9 * mul_scale, offset_z - CITYSIZE * mul_scale * ii)) * scale(mat4(1), vec3(mul_scale, mul_scale, mul_scale));
				glUniformMatrix4fv(prog->getUniform("M"), 1, GL_FALSE, &M[0][0]);
				for (int ii = 0; ii < shape->return_subsize(); ii++)
					shape->draw(ii, prog, true);	//draw earth
				}
			prog->unbind();
			
			//	******		//buildings		******

				//************************** LASER *******************************
			if (initialized_VB_laser_count > 0)
				{
				prog_laser->bind();
				glUniformMatrix4fv(prog_laser->getUniform("P"), 1, GL_FALSE, &P[0][0]);
				glUniformMatrix4fv(prog_laser->getUniform("V"), 1, GL_FALSE, &V[0][0]);
				glActiveTexture(GL_TEXTURE0);			glBindTexture(GL_TEXTURE_2D, TexLaser);
				glActiveTexture(GL_TEXTURE1);			glBindTexture(GL_TEXTURE_2D, TexLaserMask);
				glBindVertexArray(VAOLasers);

				for (int ii = 1; ii >= 0; ii--)
					{
					M = translate(mat4(1), vec3(0, 0, -4 - CITYSIZE * mul_scale * ii));
					glUniformMatrix4fv(prog_laser->getUniform("M"), 1, GL_FALSE, &M[0][0]);
					glDrawArrays(GL_POINTS, 0, initialized_VB_laser_count);
					}
				prog_laser->unbind();
				}
			//*********************************************
			// ******   pilot ******************************

			if (pilotrender && rendermode == MODE_CITYFWD)
				{
				
				glDisable(GL_BLEND);
				progs->bind();
				

				glActiveTexture(GL_TEXTURE0);		glBindTexture(GL_TEXTURE_2D, TexSuit);
				glActiveTexture(GL_TEXTURE1);		glBindTexture(GL_TEXTURE_2D, TexSuitMask);
				glActiveTexture(GL_TEXTURE8);		glBindTexture(GL_TEXTURE_CUBE_MAP, g_cubeTexture);

				glUniform1f(progs->getUniform("reflection_on"), (float)pilotrender);
				P = glm::perspective((float)(3.14159 / 3.), (float)((float)width / (float)height), 0.001f, 1.0f); //so much type casting... GLM metods are quite funny ones
				glUniformMatrix4fv(progs->getUniform("P"), 1, GL_FALSE, &P[0][0]);
				glUniformMatrix4fv(progs->getUniform("V"), 1, GL_FALSE, &V[0][0]);
				glUniform3fv(progs->getUniform("campos"), 1, &mycam.pos.x);
				mat4 Sa = scale(mat4(1), vec3(0.015, 0.015, 0.015));

				static float zangle = 0;
				zangle = delay(zangle, z_schwenk, 0.02);
				//cout << zangle << endl;
				zangle = mycam.rot_diff().y;
				mat4 Rza = rotate(mat4(1), (float)(zangle), vec3(0, 0, 1));
				mat4 Rxa = rotate(mat4(1), (float)(-3.1415926 * 0.5 + 0.25 + (0.55 * !mycam.toggleview)), vec3(1, 0, 0));
				mat4 Rya = rotate(mat4(1), (float)(3.1415926 * 0.5), vec3(0, 1, 0));
				mat4 Ta = glm::translate(glm::mat4(1.f), glm::vec3(0, -0.014 * !mycam.toggleview + (-0.002 * mycam.toggleview), -0.018 + 0.002 * !mycam.toggleview));
				mat4 Tcam = glm::translate(glm::mat4(1.f), mycam.pos);

				M = Tcam * mycam.R * Ta * Rza * Rxa * Rya * Sa;
				glUniformMatrix4fv(progs->getUniform("M"), 1, GL_FALSE, &M[0][0]);
				sphere2->draw(progs, true);
				progs->unbind();
				glEnable(GL_BLEND);
				
				}
			}
		//************************************************************************************************	
			void render_land(int width, int height, mat4 P, mat4 V, bool pilotrender, double frametime)
				{

				float mul_scale = CITYMULSCALE;

				glClearColor(0.0, 0.0, 0.0, 0.0);
				glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
				// Get current frame buffer size.

				glViewport(0, 0, width, height);

				glm::mat4 M, S, T;

				float pih = -3.1415926 / 2.0;
				glm::mat4 Rx = glm::rotate(glm::mat4(1.f), pih, glm::vec3(1, 0, 0));

				//	******		skysphere		******

				glFrontFace(GL_CW);
				glDisable(GL_DEPTH_TEST);

				glm::mat4 RxSun = glm::rotate(glm::mat4(1.f), (float)(3.1415926 * 0.5), glm::vec3(1, 0, 0));
				glm::mat4 RySun = glm::rotate(glm::mat4(1.f), (float)(-3.1415926 * 0.5 + 0.8), glm::vec3(0, 1, 0));
				T = glm::translate(glm::mat4(1.f), glm::vec3(mycam.pos));
				S = glm::scale(glm::mat4(1.f), glm::vec3(100.1, 100.1, 100.1));

				progsky->bind();

				glActiveTexture(GL_TEXTURE0);			glBindTexture(GL_TEXTURE_2D, TextureSky);
				glActiveTexture(GL_TEXTURE1);			glBindTexture(GL_TEXTURE_2D, TexGod);

				glUniformMatrix4fv(progsky->getUniform("P"), 1, GL_FALSE, &P[0][0]);
				glUniformMatrix4fv(progsky->getUniform("V"), 1, GL_FALSE, &V[0][0]);
				float ww = (2. * 3.1415926) / 8.;

				mat4 MM = T * RySun * RxSun * S;
				glUniformMatrix4fv(progsky->getUniform("M"), 1, GL_FALSE, &MM[0][0]);
				sphere->draw(prog, true);	//draw sky

				progsky->unbind();

				//****************boden********************
				progg->bind();
				glUniformMatrix4fv(progg->getUniform("P"), 1, GL_FALSE, &P[0][0]);
				glUniformMatrix4fv(progg->getUniform("V"), 1, GL_FALSE, &V[0][0]);
				glBindVertexArray(VertexArrayIDBox);
				for (int ii = 0; ii < 2; ii++)
					{
					M = translate(mat4(1), vec3(0, -40, -ii * CITYMULSCALE * CITYSIZE)) * glm::rotate(glm::mat4(1), (float)(3.1415926 * 0.5), glm::vec3(1, 0, 0)) * glm::scale(glm::mat4(1), glm::vec3(CITYSIZE * CITYMULSCALE * 0.5, CITYSIZE * CITYMULSCALE * 0.5, 1));
					//M = translate(mat4(1), vec3(0, 0, -4+ii*8))* glm::scale(glm::mat4(1), glm::vec3(20,20,20));
					glUniformMatrix4fv(progg->getUniform("M"), 1, GL_FALSE, &M[0][0]);				
					glDrawArrays(GL_TRIANGLES, 0, 6);
					}
				progg->unbind();
				//**************** ENDE boden*********************
				//****************boden LINES ********************
				progland->bind();
				glUniformMatrix4fv(progg->getUniform("P"), 1, GL_FALSE, &P[0][0]);
				glUniformMatrix4fv(progg->getUniform("V"), 1, GL_FALSE, &V[0][0]);

				glBindVertexArray(VAOland);
				for (int ii = 0; ii < 2; ii++)
					{
					M = mat4(1);// translate(mat4(1), vec3(0, 0, -ii * CITYMULSCALE * CITYSIZE))* glm::rotate(glm::mat4(1), (float)(3.1415926 * 0.5), glm::vec3(1, 0, 0))* glm::scale(glm::mat4(1), glm::vec3(CITYSIZE * CITYMULSCALE * 0.5, CITYSIZE * CITYMULSCALE * 0.5, 1));
					//M = translate(mat4(1), vec3(0, 0, -4+ii*8))* glm::scale(glm::mat4(1), glm::vec3(20,20,20));
					glUniformMatrix4fv(progg->getUniform("M"), 1, GL_FALSE, &M[0][0]);					
					glDrawArrays(GL_LINES, 0, VAOlandsize);
					}
				
				progland->unbind();
				//**************** ENDE boden*********************
				glFrontFace(GL_CCW);
				glEnable(GL_DEPTH_TEST);




				//bind shader and copy matrices
				prog->bind();

				glUniform1f(prog->getUniform("reflection_on"), 0.0);

				glUniformMatrix4fv(prog->getUniform("P"), 1, GL_FALSE, &P[0][0]);
				glUniformMatrix4fv(prog->getUniform("V"), 1, GL_FALSE, &V[0][0]);
				glUniform3fv(prog->getUniform("campos"), 1, &mycam.pos.x);

				//	******		buildings		******
			
				//	******		//buildings		******

					//************************** LASER *******************************
				if (initialized_VB_laser_count > 0)
					{
					prog_laser->bind();
					glUniformMatrix4fv(prog_laser->getUniform("P"), 1, GL_FALSE, &P[0][0]);
					glUniformMatrix4fv(prog_laser->getUniform("V"), 1, GL_FALSE, &V[0][0]);
					glActiveTexture(GL_TEXTURE0);			glBindTexture(GL_TEXTURE_2D, TexLaser);
					glActiveTexture(GL_TEXTURE1);			glBindTexture(GL_TEXTURE_2D, TexLaserMask);
					glBindVertexArray(VAOLasers);

					for (int ii = 1; ii >= 0; ii--)
						{
						M = translate(mat4(1), vec3(0, 0, -4 - CITYSIZE * mul_scale * ii));
						glUniformMatrix4fv(prog_laser->getUniform("M"), 1, GL_FALSE, &M[0][0]);
						glDrawArrays(GL_POINTS, 0, initialized_VB_laser_count);
						}
					prog_laser->unbind();
					}
				//*********************************************
				
				}
			//*****************************************************************************************
		void get_resolution(int* width, int* height)
			{
			if(!forceresolution)
				glfwGetFramebufferSize(windowManager->getHandle(), width, height);
			else
				{
				*width = FORCERESX;
				*height = FORCERESY;
				}
			}	
		//****************************************************************************************
		void render_scene(int width, int height, mat4 P, mat4 V, bool pilotrender, double frametime)
			{
			switch (rendermode)
				{
				default:
				case MODE_CITYSTATIC:
				case MODE_CITYFWD:
					render_citypilot(width * antialiasing, height * antialiasing, P, M_wobble * V, true, frametime);
				break;
				case MODE_LANDSTATIC:
				case MODE_LANDFWD:
					render_land(width * antialiasing, height * antialiasing, P, M_wobble * V, true, frametime);
				break;
				}
			}

		//****************************************************************************************
		void render_to_texture(double frametime) // aka render to framebuffer
			{
			glBindFramebuffer(GL_FRAMEBUFFER, fb);
			GLenum buffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1,GL_COLOR_ATTACHMENT2 ,GL_COLOR_ATTACHMENT3,GL_COLOR_ATTACHMENT4 };
			glDrawBuffers(5, buffers);
			int width, height;
			get_resolution(&width, &height);
			glm::mat4 V, P;
			P = glm::perspective((float)(3.14159 / 3.), (float)((float)width / (float)height), 0.1f, 1000.0f); //so much type casting... GLM metods are quite funny ones
			V = mycam.process(frametime);

			render_scene(width * antialiasing, height * antialiasing, P, M_wobble * V, true, frametime);

			glBindFramebuffer(GL_FRAMEBUFFER, 0);
			glBindTexture(GL_TEXTURE_2D, FBOcolor);
			glGenerateMipmap(GL_TEXTURE_2D);
			glBindTexture(GL_TEXTURE_2D, FBOviewpos);
			glGenerateMipmap(GL_TEXTURE_2D);
			glBindTexture(GL_TEXTURE_2D, FBOworldpos);
			glGenerateMipmap(GL_TEXTURE_2D);
			glBindTexture(GL_TEXTURE_2D, FBOworldnormal);
			glGenerateMipmap(GL_TEXTURE_2D);
			glBindTexture(GL_TEXTURE_2D, FBOgodrays);
			glGenerateMipmap(GL_TEXTURE_2D);
			}
		//*****************************************************************************************
		void render_to_cubemap(double frametime)
			{
			if (!mycam.toggleview) return;
			if (rendermode != MODE_CITYFWD) return;
			//Draw the cubemap.
			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, Cube_framebuffer);
			glFramebufferRenderbuffer(GL_DRAW_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, Cube_depthbuffer);


			glm::mat4 cubeView[6];
			vec3 campos = mycam.pos;
			/*campos.x *= -1;
			campos.y *= -1;
			campos.z *= -1;*/
			cubeView[0] = glm::lookAt(campos, campos + glm::vec3(1.0f, 0.0f, 0.0f), glm::vec3(0.0f, -1.0f, 0.0f)); // +X
			cubeView[1] = glm::lookAt(campos, campos + glm::vec3(-1.0f, 0.0f, 0.0f), glm::vec3(0.0f, -1.0f, 0.0f)); // -X
			cubeView[2] = glm::lookAt(campos, campos + glm::vec3(0.0f, 1.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f)); // +Y
			cubeView[3] = glm::lookAt(campos, campos + glm::vec3(0.0f, -1.0f, 0.0f), glm::vec3(0.0f, 0.0f, -1.0f)); // -Y
			cubeView[4] = glm::lookAt(campos, campos + glm::vec3(0.0f, 0.0f, 1.0f), glm::vec3(0.0f, -1.0f, 0.0f));// +Z
			cubeView[5] = glm::lookAt(campos, campos + glm::vec3(0.0f, 0.0f, -1.0f), glm::vec3(0.0f, -1.0f, 0.0f)); // -Z

			glm::mat4 cubeProj = glm::perspective(glm::radians(90.0f), (float)1.0f, (float) 0.5, (float)200.0);


			mat4 T = translate(mat4(1), campos);



			/*cubeView[0] = rotate(mat4(1), (float)3.1415926 * 0.5f, vec3(0, -1, 0)) * T;
			cubeView[1] = rotate(mat4(1), -(float)3.1415926 * 0.5f, vec3(0, -1, 0)) * T;
			cubeView[4] = rotate(mat4(1), (float)0.0, vec3(0, -1, 0)) * T;
			cubeView[5] = rotate(mat4(1), (float)3.1415926, vec3(0, -1, 0))*T;*/



			for (int i = 0; i < 6; ++i)
				{
				mat4 V = cubeView[i];

				DrawFace(i, cubeProj, V, frametime);
				}
			glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
			}
		//*****************************************************************************************
		void DrawFace(int iFace, mat4 P, mat4 V, double frametime)
			{
			glFramebufferTexture2D(GL_DRAW_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
								   GL_TEXTURE_CUBE_MAP_POSITIVE_X + iFace, g_cubeTexture, 0);

			GLenum status = glCheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
			if (status != GL_FRAMEBUFFER_COMPLETE)
				printf("Status error: %08x\n", status);


			render_scene(CUBE_TEXTURE_SIZE, CUBE_TEXTURE_SIZE, P, V, false, frametime);


			}
		//*****************************************************************************************
		vec2 lasercols[10] = { vec2(0.0,0), vec2(1.0,0.0), vec2(0.0,1.0), vec2(0.5,0.5), vec2(0,0.2), vec2(0.7,0), vec2(0,0.7), vec2(0.7,0.2), vec2(0,1), vec2(1,0) };
		void update_laser_temp(float frametime)
			{




			vec3 verpos[MAXLASERS];
			vec3 vercol[MAXLASERS];

			//aging
			for (int i = 0; i < active_lasers.size(); i++)
				{
				active_lasers[i].aging(frametime);
				if (active_lasers[i].age < 0)
					{
					laser_reservour_index_stack.push_back(active_lasers[i].reservour_index);
					change(laser_reservour_index_stack[laser_reservour_index_stack.size() - 1], laser_reservour_index_stack[0]);
					active_lasers.erase(active_lasers.begin() + i);
					i--;
					}
				}
			//trigger:

			if (laser_reservour_index_stack.size() > 0)
				{
				for (int i = 0; i < 10 && laser_reservour_index_stack.size()>0; i++)
					{
					float trigger_amplitude = (float)(10. - i) / 2.0;
					trigger_amplitude *= LASERTRIGGERMUL;
					int assigncount = rand() % laser_reservour_index_stack.size() / 2;
					if ((amplitude_on_frequency_10steps[i] > trigger_amplitude && (amplitude_on_frequency_10steps[i] < 100.)) || (i == 2 && beattrigger))
						for (int u = 0; u < assigncount && laser_reservour_index_stack.size()>0; u++)
							{
							//	cout << "ampl " << amplitude_on_frequency_10steps[i] << ", " << trigger_amplitude << ", " << beattrigger << endl;
							UINT num = laser_reservour_index_stack.back();
							laser_reservour_index_stack.pop_back();
							laser_ las = laser_reservour[num];
							las.age = 1.3 + frand() * 0.2;
							las.rg_col = lasercols[i];
							las.reservour_index = num;
							active_lasers.push_back(las);
							}
					}
				}
			beattrigger = false;
			//
			if (active_lasers.size() > 0)
				{

				std::sort(active_lasers.begin(), active_lasers.end(), compareInterval);


				initialized_VB_laser_count = 0;
				for (int i = 0; i < min(active_lasers.size(), MAXLASERS); i++)
					if (active_lasers[i].age > 0 && active_lasers[i].age <= 1.5)
						{
						verpos[initialized_VB_laser_count] = active_lasers[i].pos;
						vercol[initialized_VB_laser_count] = vec3(active_lasers[i].age, active_lasers[i].rg_col.x, active_lasers[i].rg_col.y);
						initialized_VB_laser_count++;
						}
				if (initialized_VB_laser_count > 0)
					{
					//	cout << "fuck " << initialized_VB_laser_count << endl;
					glBindBuffer(GL_ARRAY_BUFFER, VBLasersPos);
					glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vec3) * initialized_VB_laser_count, verpos);
					glBindBuffer(GL_ARRAY_BUFFER, VBLasersCol);
					glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vec3) * initialized_VB_laser_count, vercol);
					glBindBuffer(GL_ARRAY_BUFFER, 0);
					}
				}
			}

		void init_laser()
			{

			int cc = 0;
			for (int xx = -CITYSLOTS; xx < CITYSLOTS; xx++)
				for (int zz = -CITYSLOTS; zz < CITYSLOTS; zz++)
					{
					if (cityfield[xx + CITYSLOTS][zz + CITYSLOTS].height > 4.5)
						{
						laser_ las;
						las.pos = vec3(xx * BULDINGDIST, 2, zz * BULDINGDIST) * (float)CITYMULSCALE;

						//	las.pos = vec3(-3,0, -cc *5);
						las.fieldpos = ivec2(xx, zz);
						laser_reservour_index_stack.push_back(cc);
						las.reservour_index = cc++;
						laser_reservour.push_back(las);
						if (laser_reservour.size() >= MAXLASERS)
							{
							xx = CITYSLOTS;
							break;
							}

						}
					}
			int z;
			z = 0;
			//std::sort(laser_reservour.begin(), laser_reservour.end(), compareInterval);

			//shuffle_lasers(laser_reservour.size());

			for (int i = 0; i < 10; i++)
				{
				amplitude_on_frequency_10steps[i] = 0;
				}
			}
	};
//*********************************************************************************************************
void modechange(double frametime)
	{
	if (!mycam.toggle_auto)			return;

	static double totaltime_since_last_change = 0;
	static double seconds_in_reverse_mode = 0;
	static double seconds_since_last_reverse_mode = 0;
	static double seconds_in_helmet_mode = 0;
	static double seconds_since_last_helmet_mode = 0;

	totaltime_since_last_change += frametime;
	//record mode stats:
	if (mycam.toggleview)
		{
		seconds_in_helmet_mode += frametime;
		seconds_since_last_helmet_mode = 0;
		}
	else
		seconds_since_last_helmet_mode += frametime;
	if (mycam.rot.z > 2.0)
		{
		seconds_in_reverse_mode += frametime;
		seconds_since_last_reverse_mode = 0;
		}
	else
		seconds_since_last_reverse_mode += frametime;
	//consequences:
	bool dont_helmet = false;
	bool dont_inverse = false;
	if (seconds_in_helmet_mode > 10.0)
		{
		dont_helmet = true;
		mycam.toggleview = false;
		}
	if (seconds_since_last_helmet_mode > 35)
		{
		seconds_in_helmet_mode = 0;
		dont_helmet = false;
		}

	if (seconds_in_reverse_mode > 20.0)
		{
		dont_inverse = true;
		mycam.rot.z = 0;
		}
	if (seconds_since_last_reverse_mode > 35)
		{
		seconds_in_reverse_mode = 0;
		dont_inverse = false;
		}
	//chance for a change
	if (totaltime_since_last_change > CHANGEMODETIME)
		{
		float r = frand();
		if (r < 0.1) mycam.toggle();
		else if (r > 0.9)
			{
			if (mycam.rot.z < 1)
				mycam.rot.z = 3.1415926;
			else
				mycam.rot.z = 0;
			}
		totaltime_since_last_change = 0;
		}
	}
//******************************

//********************************************************************************
extern int running;
int main(int argc, char** argv)
	{
	srand(time(0));
	// Where the resources are loaded from
	std::string resourceDir = "../resources";

	if (argc >= 2)
		{
		resourceDir = argv[1];
		}

	Application* application = new Application();

	// Your main will always include a similar set up to establish your window
	// and GL context, etc.

	WindowManager* windowManager = new WindowManager();
	windowManager->init(1280, 720);
	windowManager->setEventCallbacks(application);
	application->windowManager = windowManager;

	// This is the code that will likely change program to program as you
	// may need to initialize or set up different data and state

	application->init(resourceDir);
	application->initGeom(resourceDir);

#ifndef NOAUDIO
	thread t1(start_recording);
#endif
	
	// Loop until the user closes the window.
	int framecount = 0;
	double fps[10] = { 0,0,0,0,0,0,0,0,0,0 };
	StopWatchMicro_ sw;


	while (!glfwWindowShouldClose(windowManager->getHandle()))
		{

		static double totaltime = 0;
		double frametime = get_last_elapsed_time();
		totaltime += frametime;
		framecount++;

		windowManager->SetFullScreen(fullscreen);


		modechange(frametime);

		/*fps[0] += frametime;
		if (framecount > 100 && frametime > 0)
			{
			cout << "fps all: " << (double)framecount / fps[0] << endl;
			cout << "mu s 1: " << fps[1] / 100. << endl;
			cout << "mu s 2: " << fps[2] / 100. << endl;
			cout << "mu s 3: " << fps[3] / 100. << endl;
			cout << "mu s 4: " << fps[4] / 100. << endl;
			cout << "mu s 5: " << fps[5] / 100. << endl;
			cout << "mu s 6: " << fps[6] / 100. << endl;
			cout << "mu s 7: " << fps[7] / 100. << endl;
			framecount = 0;
			for (int ii = 0; ii < 10; ii++)	fps[ii] = 0;
			}*/
			// Render scene.
			//Set the FFT arrays
		//	sw.start();
		application->update_laser_temp(frametime);
		//	fps[1] += sw.elapse_micro();
		//	sw.start();
		application->update_wobble_pilot(frametime);
		//fps[2] += sw.elapse_micro();
		//sw.start();
		#ifndef NOAUDIO
			application->aquire_fft_scaling_arrays();
		#endif
		
		//fps[3] += sw.elapse_micro();
	//	sw.start();
		application->render_to_cubemap(frametime);
		//	fps[4] += sw.elapse_micro();
			//sw.start();
		application->render_to_texture(frametime);
		//	fps[5] += sw.elapse_micro();
		//	sw.start();
		application->render_to_screen();
		//	fps[6] += sw.elapse_micro();
		//	sw.start();
		application->render_blur_n_screen(frametime, 0);
		application->render_blur_n_screen(frametime, 1);
		//	fps[7] += sw.elapse_micro();

			// Swap front and back buffers.
		glfwSwapBuffers(windowManager->getHandle());
		// Poll for and process events.
		glfwPollEvents();
		}
	running = FALSE;
#ifndef NOAUDIO
	t1.join();
#endif
	
	// Quit program.
	windowManager->shutdown();
	return 0;
	}
